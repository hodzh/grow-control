import { DeviceRequestMeta, DeviceResponseMeta, deviceResponseMeta, structMeta } from '../../app/model/device-io-meta';
import {DeviceIOMarker, getLength} from '../../app/model/device-io';
import { FertigateState, DeviceState, ErrorCode } from '../../app/model/device-status';
import {DeviceRequestType} from '../../app/model/device-request-type';
import {DeviceResponseType} from '../../app/model/device-response-type';
import { deviceConfig, PumpType, FlowSensorType, LevelSensorType } from '../../app/model/device-config';
import * as fs from 'fs';
import { join } from 'path';
import {deviceRequestMeta} from '../../app/model/device-io-meta';
import { DevicePartType } from '../../app/model/device-parts';

const outDir = join(__dirname, '..', '..', '..', 'arduino', 'libraries', 'GrowControlConfig');

function writeConfig() {
  const filename = join(outDir, 'Config.h');
  const stream = fs.createWriteStream(filename, {encoding: 'utf-8'});
  stream.once('open', () => {
    stream.write(`// This file is generated by arduino-gen.ts\n\n`);
    stream.write(`#pragma once\n\n`);
    writeEnum(stream, deviceConfig, camelToSnake);
    stream.write(`\n`);
    writeEnum(stream, DeviceRequestType, camelToSnake, 'REQUEST_');
    stream.write(`\n`);
    writeEnum(stream, DeviceResponseType, camelToSnake, 'RESPONSE_');
    stream.write(`\n`);
    writeEnum(stream, PumpType, camelToSnake, 'PUMP_');
    stream.write(`\n`);
    writeEnum(stream, FlowSensorType, camelToSnake, 'FLOW_SENSOR_');
    stream.write(`\n`);
    writeEnum(stream, LevelSensorType, camelToSnake, 'LEVEL_SENSOR_');
    stream.write(`\n`);
    writeEnum(stream, ErrorCode, camelToSnake, 'ERROR_');
    stream.write(`\n`);
    writeEnum(stream, DeviceIOMarker, camelToSnake, 'IOMARKER_');
    stream.write(`\n`);
    writeEnum(stream, DeviceState, camelToSnake, 'CMD_');
    stream.write(`\n`);
    writeEnum(stream, FertigateState, camelToSnake, 'FERTIGATE_STATE_');
    stream.write(`\n`);
    writeEnum(stream, DevicePartType, camelToSnake, 'PART_TYPE_');
    stream.write(`\n`);
    stream.end();
  });
}
function getNames(enumType) {
  return Object.keys(enumType).filter(key => isNaN(+key));
}
function writeEnum(stream, enumType, caseConvert, prefix = '') {
  const messages = getNames(enumType);
  messages.forEach(key => {
    stream.write(`#define ${prefix}${caseConvert(key)} ${enumType[key]}\n`);
  });
}
function camelToSnake(str) {
  return str
    .split(/(?=[A-Z])/)
    .join('_')
    .toUpperCase();
}
function camelToPascal(str) {
  return str.slice(0, 1).toUpperCase() + str.slice(1);
}
function writeRequest(stream, prefix: string, structs, requestMeta: DeviceRequestMeta) {
  Object.keys(requestMeta).forEach(name => {
    console.log(name);
    let meta = requestMeta[name];
    if (typeof meta === 'string') {
      meta = structs[meta];
    }
    writeStruct(stream, prefix + 'Request', name, meta);
  });
  stream.write(`union ${prefix}Request {\n`);
  Object.keys(requestMeta).forEach(name => {
    stream.write(`    ${prefix}Request${camelToPascal(name)} ${name};\n`);
  });
  stream.write(`};\n`);
  stream.write(`inline uint16_t get${prefix}RequestSize(uint8_t type) {\n`);
  // stream.write(`    switch(type) {\n`);
  // names.forEach(name => {
  //   stream.write(`        case REQUEST_${camelToSnake(name)}: return sizeof(Request${camelToPascal(name)});\n`);
  // });
  // stream.write(`    };\n`);
  Object.keys(requestMeta).forEach(name => {
    stream.write(`    if (type == ${camelToSnake(prefix + 'Request' + camelToPascal(name))}) return sizeof(${prefix}Request${camelToPascal(
      name)});\n`);
  });
  stream.write(`    return 0xFFFF;\n`);
  stream.write(`};\n`);
}
function writeResponse(stream, prefix: string, structs, responseMeta: DeviceResponseMeta) {
  Object.keys(responseMeta).forEach(name => {
    console.log(name);
    let meta = responseMeta[name];
    if (typeof meta === 'string') {
      meta = structs[meta];
    }
    writeStruct(stream, prefix + 'Response', name, meta);
  });
}
function writeStructs() {
  const filename = join(outDir, 'Struct.h');
  const stream = fs.createWriteStream(filename, {encoding: 'utf-8'});
  stream.once('open', () => {
    stream.write(`// This file is generated by arduino-gen.ts\n\n`);
    stream.write(`#pragma once\n\n`);
    stream.write(`#include "Config.h"\n\n`);
    Object.keys(structMeta).forEach(name => {
      console.log(name);
      writeStruct(stream, '', name, structMeta[name]);
    });
    writeResponse(stream, '', structMeta, deviceResponseMeta);
    writeRequest(stream, '', structMeta, deviceRequestMeta);
    stream.end();
  });
}
function writeStruct(stream, prefix, name, fields) {
  stream.write(`// length ${getLength(fields, structMeta)} bytes\n`);
  stream.write(`struct ${prefix}${camelToPascal(name)} {\n`);
  Object.keys(fields).forEach(key => {
    const field = fields[key];
    const type = getType(field);
    let length = typeof field !== 'string' && typeof field.length === 'number' ? `[${field.length}]` : '';
    writeStructField(stream, key, type, length);
  });
  stream.write(`};\n`);
}
function writeStructField(stream, name, type, length) {
  stream.write(`    ${type} ${name}${length};\n`);
}
function getType(field) {
  if (typeof field === 'string') {
    return camelToPascal(field);
  }
  switch (field.type) {
    case 'uint8':
      return 'uint8_t';
    case 'uint16':
      return 'uint16_t';
    case 'uint32':
      return 'uint32_t';
    case 'uint8[]':
      return `uint8_t`;
    case 'uint16[]':
      return `uint16_t`;
    case 'uint32[]':
      return `uint32_t`;
    case 'object':
      return `${camelToPascal(field.itemMeta)}`;
    case 'list':
      return `${camelToPascal(field.itemMeta)}`;
  }
}

export async function genArduino() {
  writeConfig();
  writeStructs();
}
